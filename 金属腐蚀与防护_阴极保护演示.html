<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é‡‘å±é˜´æä¿æŠ¤æŠ€æœ¯æ¼”ç¤ºç³»ç»Ÿ</title>
    <style>
        :root {
            --bg-color: #f5f7fa;
            --panel-bg: #ffffff;
            --primary: #1890ff;
            --danger: #ff4d4f;
            --success: #52c41a;
            --text-dark: #2c3e50;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
            background: var(--bg-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- é¡¶éƒ¨å¯¼èˆª --- */
        header {
            background: #263238;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 10;
        }

        h1 { color: #fff; font-size: 18px; margin: 0; letter-spacing: 1px; }

        .nav-tabs {
            display: flex;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            padding: 4px;
            gap: 4px;
        }

        .tab-btn {
            background: transparent;
            border: none;
            color: #b0bec5;
            padding: 8px 20px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: 500;
            transition: all 0.2s;
        }
        .tab-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
        .tab-btn.active { background: var(--primary); color: #fff; font-weight: bold; }

        .btn-reset {
            background: #ffc107;
            color: #333;
            border: none;
            padding: 6px 16px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
        }

        /* --- ä¸»å†…å®¹ --- */
        main {
            flex: 1;
            padding: 20px;
            display: flex;
            gap: 20px;
            position: relative;
        }

        .view-panel {
            flex: 1;
            background: var(--panel-bg);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid #e1e4e8;
        }

        .panel-head {
            padding: 12px 20px;
            border-bottom: 1px solid #eee;
            background: #fafbfc;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-title { font-weight: bold; color: var(--text-dark); margin: 0; }
        
        .status-tag {
            font-size: 13px;
            padding: 4px 10px;
            border-radius: 4px;
            font-weight: bold;
        }
        .tag-green { background: #f6ffed; color: #52c41a; border: 1px solid #b7eb8f; }
        .tag-red { background: #fff1f0; color: #f5222d; border: 1px solid #ffa39e; }

        .canvas-container {
            flex: 1;
            position: relative;
            background: linear-gradient(180deg, #e3f2fd 0%, #bbdefb 100%);
        }

        canvas { width: 100%; height: 100%; display: block; }

        /* --- åº•éƒ¨æ§åˆ¶æ  --- */
        .controls {
            height: 70px;
            background: #fff;
            border-top: 1px solid #eee;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }

        /* æ–°ç‰ˆå¼€å…³æ ·å¼ (åˆ†ç¦»å¼) */
        .switch-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 20px;
            background: #f8f9fa;
            border-radius: 30px;
            border: 1px solid #eee;
        }

        /* çº¯å‡€çš„æ»‘å— */
        .toggle-btn {
            width: 50px;
            height: 28px;
            background: #bdc3c7;
            border-radius: 14px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        .toggle-btn::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        /* æ¿€æ´»çŠ¶æ€ */
        .toggle-btn.active { background: var(--success); }
        .toggle-btn.active::after { transform: translateX(22px); }

        .switch-label { font-weight: bold; color: #555; font-size: 14px; }
        .status-text { font-family: monospace; font-weight: bold; font-size: 16px; min-width: 40px; }

        .hidden { display: none !important; }

    </style>
</head>
<body>

<header>
    <h1>âš¡ é‡‘å±é˜´æä¿æŠ¤æŠ€æœ¯æ¼”ç¤ºç³»ç»Ÿ</h1>
    <div class="nav-tabs">
        <button class="tab-btn active" onclick="setMode(1)">1. ç‰ºç‰²é˜³ææ³•</button>
        <button class="tab-btn" onclick="setMode(2)">2. å¤–åŠ ç”µæºæ³• (ICCP)</button>
        <button class="tab-btn" onclick="setMode(3)">3. å¯¹æ¯”æ€»ç»“</button>
    </div>
    <button class="btn-reset" onclick="resetAll()">é‡ç½®æ¼”ç¤º</button>
</header>

<main>
    <!-- æ¨¡å— A: ç‰ºç‰²é˜³æ -->
    <div id="panel-sa" class="view-panel">
        <div class="panel-head">
            <h3 class="panel-title">ç‰ºç‰²é˜³æä¿æŠ¤æ³•</h3>
            <span id="tag-sa" class="status-tag tag-green">â— ä¿æŠ¤ä¸­</span>
        </div>
        <div class="canvas-container">
            <canvas id="cvs-sa"></canvas>
        </div>
        <div class="controls">
            <span style="color:#666;font-size:14px;">ğŸ’¡ æç¤ºï¼šè§‚å¯Ÿå·¦ä¾§é”Œé˜³æçš„é€æ¸æ¶ˆè€—è¿‡ç¨‹ï¼Œå³ä¾§é“ç»“æ„å—åˆ°ä¿æŠ¤ä¸ä¼šç”Ÿé”ˆ</span>
        </div>
    </div>

    <!-- æ¨¡å— B: ICCP -->
    <div id="panel-iccp" class="view-panel hidden">
        <div class="panel-head">
            <h3 class="panel-title">å¤–åŠ ç”µæºæ³• (ICCP)</h3>
            <span id="tag-iccp" class="status-tag tag-green">â— ç”µæºå¼€å¯</span>
        </div>
        <div class="canvas-container">
            <canvas id="cvs-iccp"></canvas>
        </div>
        <div class="controls">
            <!-- ä½ çš„éœ€æ±‚ï¼šå¼€å…³æŠŠå†…å®¹ä¹Ÿå±•ç¤ºåˆ°æŒ‰é’®é‡Œäº†ä¸å¥½çœ‹ -->
            <!-- è§£å†³æ–¹æ¡ˆï¼šåˆ†å¼€å†™ï¼Œå·¦è¾¹æ˜¯å¼€å…³ï¼Œå³è¾¹æ˜¯æ–‡å­— -->
            <div class="switch-wrapper">
                <span class="switch-label">ç›´æµç”µæº:</span>
                <div id="iccp-toggle" class="toggle-btn active" onclick="togglePower()"></div>
                <span id="iccp-state-text" class="status-text" style="color:var(--success)">ON</span>
            </div>
        </div>
    </div>
</main>

<script>
    /** é…ç½® */
    const CFG = {
        electronSpeed: 0.5, // ç”µå­æ›´æ…¢ï¼Œä¾¿äºè§‚å¯Ÿ
        zincMaxLife: 3000,
        zincDecayRate: 0.05, // é˜³ææ¶ˆè€—é€Ÿåº¦ï¼ˆåŠ å¿«ï¼‰
        colors: {
            wire: '#2c3e50',
            water: 'rgba(33, 150, 243, 0.3)',
            sky: '#e3f2fd',
            zinc: '#b0bec5',
            iron: '#5c6bc0',
            inert: '#455a64'
        }
    };

    /** çŠ¶æ€ */
    const state = {
        mode: 1,
        sa: { life: 100, electrons: [], rust: 0, wave: 0 },
        iccp: { on: true, electrons: [], bubbles: [], rust: 0, wave: 0 }
    };

    const cvsSA = document.getElementById('cvs-sa');
    const ctxSA = cvsSA.getContext('2d');
    const cvsICCP = document.getElementById('cvs-iccp');
    const ctxICCP = cvsICCP.getContext('2d');
    // æ ‡è®°å½“å‰ç»˜åˆ¶åœºæ™¯ï¼ˆsa / iccpï¼‰ï¼Œç”¨äºç¬¦å·æ˜¾ç¤ºåˆ¤æ–­
    let CURRENT_SCENE = 'sa';

    // --- æ ¸å¿ƒé€»è¾‘ ---

    function init() {
        resize();
        window.addEventListener('resize', resize);
        loop();
    }

    function resize() {
        [cvsSA, cvsICCP].forEach(cvs => {
            if(cvs.parentElement) {
                cvs.width = cvs.parentElement.clientWidth;
                cvs.height = cvs.parentElement.clientHeight;
            }
        });
    }

    window.setMode = function(m) {
        state.mode = m;
        document.querySelectorAll('.tab-btn').forEach((b,i)=> b.classList.toggle('active', i+1===m));
        
        const p1 = document.getElementById('panel-sa');
        const p2 = document.getElementById('panel-iccp');
        
        if(m===1) { p1.classList.remove('hidden'); p2.classList.add('hidden'); }
        else if(m===2) { p1.classList.add('hidden'); p2.classList.remove('hidden'); }
        else { p1.classList.remove('hidden'); p2.classList.remove('hidden'); }
        
        setTimeout(resize, 10);
    };

    window.togglePower = function() {
        state.iccp.on = !state.iccp.on;
        if(!state.iccp.on) state.iccp.electrons = [];
        updateUI();
    };

    window.resetAll = function() {
        state.sa.life = 100; state.sa.rust = 0; state.sa.electrons = [];
        state.iccp.on = true; state.iccp.rust = 0; state.iccp.electrons = [];
        updateUI();
    };

    function updateUI() {
        const t = document.getElementById('iccp-toggle');
        const txt = document.getElementById('iccp-state-text');
        const tag = document.getElementById('tag-iccp');
        
        if(state.iccp.on) {
            t.classList.add('active');
            txt.innerText = "ON"; txt.style.color = "var(--success)";
            tag.className = "status-tag tag-green"; tag.innerText = "â— ç”µæºå¼€å¯";
        } else {
            t.classList.remove('active');
            txt.innerText = "OFF"; txt.style.color = "#999";
            tag.className = "status-tag tag-red"; tag.innerText = "â— å¤±å»ä¿æŠ¤";
        }
    }

    function loop() {
        // SA Logic
        if(state.mode !== 2) {
            const s = state.sa;
            if(s.life > 0) {
                s.life -= CFG.zincDecayRate; // ä½¿ç”¨é…ç½®çš„æ¶ˆè€—é€Ÿåº¦
                if(Math.random()<0.03) s.electrons.push({t:0});
                if(s.rust > 0) s.rust -= 0.5;
            } else {
                s.life = 0;
                s.electrons = []; // è€—å°½ååœæ­¢ç”µå­æµåŠ¨
                if(s.rust < 100) s.rust += 0.8; // åŠ å¿«ç”Ÿé”ˆé€Ÿåº¦
            }
            // UI Tag Update
            const tag = document.getElementById('tag-sa');
            if(s.life <= 0) {
                tag.className = "status-tag tag-red"; tag.innerText = "âš ï¸ é˜³æå·²è€—å°½";
            } else if(s.life <= 15) {
                tag.className = "status-tag"; tag.innerText = "âš¡ é˜³æå³å°†è€—å°½";
                tag.style.background = "#fff1f0"; tag.style.color = "#ff4d4f"; tag.style.border = "1px solid #ffa39e";
            } else if(s.life <= 40) {
                tag.className = "status-tag"; tag.innerText = "ğŸ”‹ é˜³ææ¶ˆè€—ä¸­";
                tag.style.background = "#fff7e6"; tag.style.color = "#fa8c16"; tag.style.border = "1px solid #ffd591";
            } else {
                tag.className = "status-tag tag-green"; tag.innerText = "âœ“ ä¿æŠ¤æ­£å¸¸";
            }
            updateElectrons(s.electrons);
            s.wave += 0.02;
            drawScene(ctxSA, 'sa');
        }

        // ICCP Logic
        if(state.mode !== 1) {
            const s = state.iccp;
            if(s.on) {
                if(Math.random()<0.03) s.electrons.push({t:0});
                if(Math.random()<0.05) s.bubbles.push({x:(Math.random()-0.5)*20, y:0});
                if(s.rust > 0) s.rust -= 0.5;
            } else {
                if(s.rust < 100) s.rust += 0.2;
            }
            updateElectrons(s.electrons);
            updateBubbles(s.bubbles);
            s.wave += 0.02;
            drawScene(ctxICCP, 'iccp');
        }

        requestAnimationFrame(loop);
    }

    function updateElectrons(arr) {
        for(let i=arr.length-1; i>=0; i--) {
            arr[i].t += 0.005 * CFG.electronSpeed;
            if(arr[i].t >= 1) arr.splice(i,1);
        }
    }
    function updateBubbles(arr) {
        for(let i=arr.length-1; i>=0; i--) {
            arr[i].y += 1.5; if(arr[i].y > 150) arr.splice(i,1);
        }
    }

    // --- ç»˜å›¾ (ä¿®å¤ï¼šå¯¹ç§°æ€§ã€é®æŒ¡é—®é¢˜ã€ç”µæ± å¤–è§‚) ---

    function drawScene(ctx, type) {
        CURRENT_SCENE = type;
        const w = ctx.canvas.width;
        const h = ctx.canvas.height;
        if(w===0) return;
        
        ctx.clearRect(0,0,w,h);
        const data = (type==='sa') ? state.sa : state.iccp;

        // 1. æ°´é¢
        const waterLevel = h * 0.45;
        ctx.fillStyle = CFG.colors.water;
        ctx.beginPath();
        ctx.moveTo(0, h); ctx.lineTo(0, waterLevel);
        for(let x=0; x<=w; x+=20) ctx.lineTo(x, waterLevel + Math.sin(x*0.01 + data.wave)*8);
        ctx.lineTo(w, h); ctx.fill();

        // å¸ƒå±€åæ ‡
        const floorY = h * 0.8;
        const centerX = w * 0.5;
        // å·¦å³å®Œå…¨å¯¹ç§°
        const offset = Math.min(w * 0.25, 200); 
        const anodeX = centerX - offset;
        const cathodeX = centerX + offset;
        const wireH = h * 0.25; // å¯¼çº¿é«˜åº¦

        // 2. å…ˆè®¡ç®—é‡‘å±å—ä½ç½®ï¼ˆä¸ºäº†å¯¼çº¿è¿æ¥ï¼‰
        let anodeTop = {x: anodeX, y: floorY-120};
        let cathodeTop = {x: cathodeX, y: floorY-120};

        // è®¡ç®—å®é™…é«˜åº¦
        if(type==='sa') {
            const lifePct = data.life/100;
            // è®©é˜³æå®Œå…¨æ¶ˆå¤±çš„æ•ˆæœæ›´æ˜æ˜¾
            const hNow = lifePct <= 0 ? 5 : 120 * (0.05 + 0.95 * lifePct);
            anodeTop = {x: anodeX, y: floorY - hNow};
        }

        // 3. å…ˆç»˜åˆ¶ç”µæºä¸å¯¼çº¿ï¼ˆåœ¨é‡‘å±å—ä¹‹å‰ï¼Œè¿™æ ·ç¬¦å·å°±ä¸ä¼šè¢«é®æŒ¡ï¼‰
        ctx.lineWidth = 4;
        ctx.lineJoin = 'round';
        ctx.strokeStyle = CFG.colors.wire;
        ctx.beginPath();

        let path = []; // ç”µå­è·¯å¾„

        if(type==='sa') {
            // ç®€å•å›è·¯ï¼šå·¦ -> ä¸Š -> å³ -> ä¸‹
            ctx.moveTo(anodeTop.x, anodeTop.y);
            ctx.lineTo(anodeTop.x, wireH);
            ctx.lineTo(cathodeTop.x, wireH);
            ctx.lineTo(cathodeTop.x, cathodeTop.y);
            ctx.stroke();

            // è·¯å¾„
            path = [
                anodeTop, 
                {x:anodeTop.x, y:wireH}, 
                {x:cathodeTop.x, y:wireH}, 
                cathodeTop
            ];
        } else {
            // ICCP å›è·¯ï¼šè¿æ¥ç”µæº
            // ä½ çš„éœ€æ±‚ï¼šç”µæ± ç”»å¾—å¥½ä¸€ç‚¹ï¼Œçº¿å¯¹ç§°
            const boxY = h * 0.12; 
            const boxW = 140;
            const boxH = 70;
            const termL = centerX - 40;
            const termR = centerX + 40;
            const termY = boxY + boxH; // æ¥çº¿æŸ±Y

            // å·¦è·¯å¯¼çº¿: é˜³æ -> ä¸Š -> å³ -> æ¥çº¿æŸ±å·¦
            ctx.moveTo(anodeTop.x, anodeTop.y);
            ctx.lineTo(anodeTop.x, wireH + 20); // ç¨å¾®æ‹ä¸€ä¸‹
            ctx.lineTo(termL, wireH + 20);
            ctx.lineTo(termL, termY);
            
            // å³è·¯å¯¼çº¿: é˜´æ -> ä¸Š -> å·¦ -> æ¥çº¿æŸ±å³
            ctx.moveTo(cathodeTop.x, cathodeTop.y);
            ctx.lineTo(cathodeTop.x, wireH + 20);
            ctx.lineTo(termR, wireH + 20);
            ctx.lineTo(termR, termY);
            
            ctx.stroke();

            // ç»˜åˆ¶é«˜çº§ç”µæº
            drawPowerDevice(ctx, centerX, boxY, boxW, boxH, data.on);

            // è·¯å¾„: ç”µæºå³(-) -> é˜´æ
            path = [
                {x:termR, y:termY},
                {x:termR, y:wireH + 20},
                {x:cathodeTop.x, y:wireH + 20},
                cathodeTop
            ];
        }

        // 4. å†ç»˜åˆ¶é‡‘å±å—ï¼ˆåœ¨å¯¼çº¿ä¹‹åï¼Œç¬¦å·å°±ä¸ä¼šè¢«é®æŒ¡ï¼‰
        // A. é˜³æ
        if(type==='sa') {
            const lifePct = data.life/100;
            // é˜³ææ¶ˆè€—æ•ˆæœï¼šé«˜åº¦å’Œå®½åº¦éƒ½å˜åŒ–ï¼Œå®Œå…¨è€—å°½æ—¶å‡ ä¹æ¶ˆå¤±
            const hNow = lifePct <= 0 ? 5 : 120 * (0.05 + 0.95 * lifePct);
            const wNow = lifePct <= 0 ? 20 : 80 * (0.25 + 0.75 * lifePct);
            drawBlock(ctx, anodeX, floorY, wNow, hNow, 'zinc', 0, lifePct);
        } else {
            drawBlock(ctx, anodeX, floorY, 60, 120, 'inert', 0, 1);
            drawBubbles(ctx, anodeX, floorY-120, data.bubbles);
        }

        // B. é˜´æ
        drawBlock(ctx, cathodeX, floorY, 80, 120, 'iron', data.rust, 1);

        // 5. ç»˜åˆ¶ç”µå­ï¼ˆæœ€åç»˜åˆ¶ï¼Œç¡®ä¿å¯è§ï¼‰
        if( (type==='sa' && data.life>0) || (type==='iccp' && data.on) ) {
            drawElectrons(ctx, data.electrons, path);
        }
    }

    // --- ç»˜åˆ¶ç»„ä»¶ç»†èŠ‚ ---

    function drawBlock(ctx, cx, by, w, h, type, rust, lifePct = 1) {
        const x = cx - w/2;
        const y = by - h;
        const depth = 15;
        
        // è°ƒè‰²æ¿ï¼ˆå¸¦æ¸å˜ï¼Œé‡‘å±æ„Ÿæ›´å¼ºï¼‰
        const fade = Math.max(lifePct, 0); // é˜³ææ¶ˆè€—æ—¶æ•´ä½“æ·¡åŒ–
        const palette = {
            zinc: {
                face: [`rgba(222,230,236,${fade})`, `rgba(194,205,214,${fade})`],
                top:  [`rgba(244,247,249,${fade})`, `rgba(220,230,236,${fade})`],
                side: [`rgba(176,190,197,${fade})`, `rgba(146,158,166,${fade})`],
                stroke: `rgba(146,158,166,${fade})`,
                highlight: `rgba(255,255,255,${0.18*fade})`
            },
            iron: {
                face: ['#7f8ac9', '#5f6bb8'],
                top:  ['#aab4f0', '#7f8ac9'],
                side: ['#5460a6', '#454e8d'],
                stroke: '#3d447a',
                highlight: 'rgba(255,255,255,0.12)'
            },
            inert: {
                face: ['#4a5964', '#39444c'],
                top:  ['#62727e', '#4a5964'],
                side: ['#2b3339', '#22292e'],
                stroke: '#1d252a',
                highlight: 'rgba(255,255,255,0.08)'
            }
        }[type];

        // ä¾§é¢
        const sideGrad = ctx.createLinearGradient(x+w, y-depth, x+w, y+h);
        sideGrad.addColorStop(0, palette.side[0]);
        sideGrad.addColorStop(1, palette.side[1]);
        ctx.fillStyle = sideGrad;
        ctx.beginPath(); ctx.moveTo(x+w,y); ctx.lineTo(x+w+depth,y-depth); 
        ctx.lineTo(x+w+depth,y+h-depth); ctx.lineTo(x+w,y+h); ctx.fill();

        // é¡¶é¢
        const topGrad = ctx.createLinearGradient(x, y-depth, x+w+depth, y-depth);
        topGrad.addColorStop(0, palette.top[0]);
        topGrad.addColorStop(1, palette.top[1]);
        ctx.fillStyle = topGrad;
        ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+depth,y-depth);
        ctx.lineTo(x+w+depth,y-depth); ctx.lineTo(x+w,y); ctx.fill();

        // æ­£é¢
        const faceGrad = ctx.createLinearGradient(x, y, x, y+h);
        faceGrad.addColorStop(0, palette.face[0]);
        faceGrad.addColorStop(1, palette.face[1]);
        ctx.fillStyle = faceGrad;
        ctx.fillRect(x,y,w,h);

        // é«˜å…‰é®ç½©
        ctx.fillStyle = palette.highlight;
        ctx.fillRect(x, y, w, h*0.25);

        // è¾¹æ¡†çº¿æ¡
        ctx.strokeStyle = palette.stroke;
        ctx.lineWidth = 1.2;
        ctx.strokeRect(x, y, w, h);

        // é“é”ˆ
        if(type==='iron' && rust>0) {
            ctx.save(); ctx.beginPath(); ctx.rect(x,y,w,h); ctx.clip();
            ctx.fillStyle = `rgba(140,50,30,${rust/100 * 0.9})`;
            ctx.fillRect(x,y,w,h);
            // é”ˆæ–‘
            if(rust>20) {
                ctx.fillStyle='rgba(60,20,10,0.5)';
                for(let i=0; i<8; i++) {
                    ctx.beginPath(); 
                    ctx.arc(x+w*0.2+(i*23)%w, y+h*0.2+(i*17)%h, 4+i, 0, 6.28); 
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        // æ–‡å­—æ ‡ç­¾
        ctx.fillStyle = '#333';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        let lbl = type==='zinc'?'Zn (é˜³æ)':(type==='iron'?'Feï¼ˆè¢«ä¿æŠ¤ / é˜´æï¼‰':'è¾…åŠ©é˜³æ');
        ctx.fillText(lbl, cx, by+20);

        // ææ€§ç¬¦å· - ç²¾ç¾ä¸”åŒºåˆ†æ­£è´Ÿ
        // è§„åˆ™ï¼š
        // - SA æ¨¡å¼ï¼šé”Œä¸ºè´Ÿ(-)ï¼Œé“ä¸ºæ­£(+)
        // - ICCP æ¨¡å¼ï¼šè¾…åŠ©é˜³æ(inert)ä¸ºæ­£(+)ï¼Œè¢«ä¿æŠ¤é“ä¸ºè´Ÿ(-)
        // ç”µææœ¬èº«ä¸å†æ ‡æ³¨ + / âˆ’ï¼ˆZnã€Feã€è¾…åŠ©é˜³æéƒ½ä¸æ˜¾ç¤ºï¼‰
        const polarity = null;

        if(polarity && lifePct > 0.02) {
            const symbolY = y - depth - 25;
            
            // ç»˜åˆ¶ç²¾ç¾çš„æ ‡ç­¾èƒŒæ™¯
            ctx.save();
            
            // é˜´å½±æ•ˆæœ
            ctx.shadowColor = 'rgba(0,0,0,0.15)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 2;
            
            // èƒŒæ™¯åœ†å½¢
            const bgGradient = ctx.createRadialGradient(cx, symbolY, 0, cx, symbolY, 22);
            const isNegative = polarity === 'âˆ’';
            if(isNegative) {
                bgGradient.addColorStop(0, '#fff9e6'); // æ¸©æš–é»„
                bgGradient.addColorStop(1, '#ffeaa7');
            } else {
                bgGradient.addColorStop(0, '#ffe6e6'); // æŸ”å’Œçº¢
                bgGradient.addColorStop(1, '#ffb3b3');
            }
            ctx.fillStyle = bgGradient;
            ctx.beginPath();
            ctx.arc(cx, symbolY, 20, 0, 6.28);
            ctx.fill();
            
            ctx.shadowColor = 'transparent';
            
            // è¾¹æ¡†
            ctx.strokeStyle = isNegative ? '#ff9f43' : '#ff6b6b';
            ctx.lineWidth = 2.5;
            ctx.stroke();
            
            ctx.restore();
            
            // ç»˜åˆ¶ç¬¦å·
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = isNegative ? '#ff9f43' : '#ff6b6b';
            ctx.fillText(polarity, cx, symbolY);
        }
    }

    // ç»˜åˆ¶é«˜çº§ç”µæº (ä½ çš„éœ€æ±‚ï¼šç”»å¥½ä¸€ç‚¹ï¼Œçº¿ä½ç½®å¯¹ç§°)
    function drawPowerDevice(ctx, cx, y, w, h, isOn) {
        const x = cx - w/2;
        
        // 1. æœºç®±é˜´å½±
        ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = 10;
        
        // 2. æœºç®±ä¸»ä½“ (æ¸å˜ç°)
        const grd = ctx.createLinearGradient(x,y,x,y+h);
        grd.addColorStop(0, '#f5f5f5'); grd.addColorStop(1, '#e0e0e0');
        ctx.fillStyle = grd;
        ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.fill();
        ctx.shadowBlur = 0; // reset
        
        // è¾¹æ¡†
        ctx.strokeStyle = '#bdbdbd'; ctx.lineWidth = 1; ctx.stroke();

        // 3. æ¶²æ™¶å± (é»‘è‰²èƒŒæ™¯ï¼Œç»¿è‰²å­—)
        ctx.fillStyle = '#222';
        ctx.fillRect(x + 15, y + 10, w - 30, 25);
        if(isOn) {
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 16px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText("12.0 V", cx, y + 28);
        } else {
            ctx.fillStyle = '#444';
            ctx.font = 'bold 16px monospace';
            ctx.textAlign = 'center';
            ctx.fillText("---", cx, y + 28);
        }

        // 4. æ¥çº¿æŸ± (çº¢/é»‘)
        const termY = y + h - 12;
        const termL = cx - 40;
        const termR = cx + 40;
        
        // å·¦æ¥çº¿æŸ± (çº¢ +)
        ctx.beginPath(); ctx.arc(termL, termY, 8, 0, 6.28);
        ctx.fillStyle = '#d32f2f'; ctx.fill();
        ctx.strokeStyle = '#b71c1c'; ctx.lineWidth=2; ctx.stroke();

        // å³æ¥çº¿æŸ± (é»‘ -)
        ctx.beginPath(); ctx.arc(termR, termY, 8, 0, 6.28);
        ctx.fillStyle = '#212121'; ctx.fill();
        ctx.strokeStyle = '#000'; ctx.stroke();

        // 5. ç¬¦å· (ç”»åœ¨é¢æ¿ä¸Šï¼Œæ°¸ä¹…å¯è§)
        ctx.font = 'bold 16px Arial';
        ctx.fillStyle = '#d32f2f'; 
        ctx.fillText("+", termL, termY - 12); // + å·åœ¨çº¢è‰²æŸ±ä¸Šæ–¹
        
        ctx.fillStyle = '#000'; 
        ctx.fillText("-", termR, termY - 12); // - å·åœ¨é»‘è‰²æŸ±ä¸Šæ–¹
    }

    function drawElectrons(ctx, list, path) {
        // ç”µå­ï¼šæ›´å¤§ã€æ›´äº®ã€æ ‡è®°æ¸…æ™°
        list.forEach(e => {
            // è·¯å¾„è®¡ç®—
            const segs = path.length - 1;
            const step = 1/segs;
            const idx = Math.floor(e.t / step);
            const sub = (e.t % step) / step;
            if(idx >= segs) return;
            
            const p1 = path[idx]; const p2 = path[idx+1];
            const x = p1.x + (p2.x - p1.x)*sub;
            const y = p1.y + (p2.y - p1.y)*sub;

            // å¤–å±‚å…‰æ™• - æ›´å¤§åŠå¾„
            const outerGlow = ctx.createRadialGradient(x,y,0,x,y,18);
            outerGlow.addColorStop(0, 'rgba(255,235,59,0.8)');
            outerGlow.addColorStop(0.5, 'rgba(255,235,59,0.4)');
            outerGlow.addColorStop(1, 'rgba(255,235,59,0)');
            ctx.fillStyle = outerGlow;
            ctx.beginPath(); ctx.arc(x,y,18,0,6.28); ctx.fill();

            // å†…å±‚å…‰æ™•
            const innerGlow = ctx.createRadialGradient(x,y,0,x,y,10);
            innerGlow.addColorStop(0, 'rgba(255,245,157,1)');
            innerGlow.addColorStop(1, 'rgba(255,235,59,0.6)');
            ctx.fillStyle = innerGlow;
            ctx.beginPath(); ctx.arc(x,y,10,0,6.28); ctx.fill();

            // æ ¸å¿ƒåœ†çƒ - æ›´å¤§
            ctx.fillStyle = '#fff176';
            ctx.beginPath(); ctx.arc(x,y,8,0,6.28); ctx.fill();
            ctx.strokeStyle='#fbc02d'; ctx.lineWidth=1.5; ctx.stroke();
            
            // e- æ ‡è®°
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#000';
            ctx.fillText("eâˆ’", x, y);
        });
    }

    function drawBubbles(ctx, x, y, list) {
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        list.forEach(b => {
            ctx.beginPath(); ctx.arc(x+b.x, y-b.y, 3, 0, 6.28); ctx.fill();
        });
    }

    window.onload = init;

</script>
</body>
</html>